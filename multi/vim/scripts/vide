#! /bin/bash

FileName=$1
CurLine=$2
CurColumn=$3

# must use single [] to use bourne evaluation that requires numbers for -eq.
if [ -n "$CurLine" -a $CurLine -eq $CurLine ] ; then
    # zero makes no column a column
    cursor_jump="call cursor($CurLine,0$CurColumn)"
else
    # if CurLine is not a number, then we received multiple files.
    FileName=$*
    CurLine=
    CurColumn=
    cursor_jump="echo"
fi

is_neovim=0
vim=gvim
if [[ -x "/usr/local/bin/mvim" ]] ; then
    # MacVim is a mac frontend for vim.
    vim=mvim
elif [[ -x "/usr/local/bin/vimr" ]] ; then
    # VimR is a mac frontend for neovim.
    vim="vimr --nvim"
    is_neovim=1
elif [[ -x "/usr/local/bin/nvim" ]] ; then
    vim="nvim"
    is_neovim=1
fi

# Support opening new server or focusing vim with no filename and opening
# files in new/existing server.
if [[ -z "$FileName" ]] ; then
    if [[ -z "$($vim --serverlist | grep -e "\bVIDE\b")" ]] ; then
        remote="+ScratchNoSplit"
    else
        # videinvoke probably foregrounds, but not much else useful to put
        # here.
        remote="--remote-expr foreground()"
    fi
else
    remote="--remote-silent"
fi


if [[ $is_neovim == 1 ]] ; then
    vim="$vim $remote --cmd \"let g:server_addr = serverstart('vide')\""
else
    vim="$vim --servername Vide $remote"
fi

# Passing these quoted strings causes some command text to appear (cal
# foreground) and requires press enter. Doesn't occur if I paste the printed
# text into this script.
vim="$vim +\"$cursor_jump\" +\"runtime videinvoke.vim\" $FileName"
# TODO: MacVim fails to source videinvoke and tries to edit it instead.
#~ vim="$vim +\"$cursor_jump\" $FileName"
echo $vim
$vim

# vimr --nvim --remote-silent --cmd "let g:server_addr = serverstart('vide')"
# vimr --remote-silent --cmd "let g:server_addr = serverstart('vide')"
