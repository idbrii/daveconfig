#! /bin/bash

FileName=$1
CurLine=$2
CurColumn=$3

if [[ -z "$FileName" ]] ; then
    # always have a file or remote will complain
    FileName=hello
fi

# must use single [] to use bourne evaluation that requires numbers for -eq.
if [ $CurLine -eq $CurLine ] ; then
    # zero makes no column a column
    cursor_jump="call cursor($CurLine,0$CurColumn)"
else
    # if CurLine is not a number, then we received multiple files.
    FileName=$*
    CurLine=
    CurColumn=
    cursor_jump='let junk=0'
fi

is_neovim=0
vim=gvim
if [[ -x "/usr/local/bin/mvim" ]] ; then
    # MacVim is a mac frontend for vim.
    vim=mvim
elif [[ -x "/usr/local/bin/vimr" ]] ; then
    # VimR is a mac frontend for neovim.
    vim="vimr --nvim"
    is_neovim=1
elif [[ -x "/usr/local/bin/nvim" ]] ; then
    vim="nvim"
    is_neovim=1
fi

if [[ $is_neovim == 1 ]] ; then
    vim="$vim --remote-silent --cmd \"let g:server_addr = serverstart('vide')\""
else
    vim="$vim --servername Vide --remote-silent"
fi

# Passing these quoted strings causes some command text to appear (cal
# foreground) and requires press enter. Doesn't occur if I paste the printed
# text into this script.
vim="$vim +\"$cursor_jump\" +\"runtime videinvoke.vim\" $FileName"
echo $vim
$vim

# vimr --nvim --remote-silent --cmd "let g:server_addr = serverstart('vide')"
# vimr --remote-silent --cmd "let g:server_addr = serverstart('vide')"
